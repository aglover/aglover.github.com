<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | The Disco Blog]]></title>
  <link href="http://thediscoblog.com/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://thediscoblog.com/"/>
  <updated>2013-11-25T14:15:21-05:00</updated>
  <id>http://thediscoblog.com/</id>
  <author>
    <name><![CDATA[Andrew Glover]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Elasticsearch in a box]]></title>
    <link href="http://thediscoblog.com/blog/2013/11/25/elasticsearch-in-a-box/"/>
    <updated>2013-11-25T13:42:00-05:00</updated>
    <id>http://thediscoblog.com/blog/2013/11/25/elasticsearch-in-a-box</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/mine/esbox.jpg">Are you looking to get going to <a href="http://thediscoblog.com/blog/categories/elasticsearch/">Elasticsearch</a> as quickly as possible without having to worry about <a href="http://thediscoblog.com/blog/2013/05/17/elasticsearch-on-ec2-in-less-than-60-seconds/">installing Java or Elasticsearch</a> itself? Are you looking for a repeatable and automated mechanism for bringing up Elasticsearch instances for developmental and or testing purposes? While there's certainly a number of <a href="http://www.elasticsearch.org/">Elasticsearch</a>-as-a-platform service providers out there, there's one other option: use <a href="https://github.com/aglover/coffer">Elasticsearch-in-a-box</a>.</p>

<p>Elasticsearch-in-a-box is a freely available <a href="http://www.vagrantbox.es/">Vagrant base box</a>. What that means is that you can quickly fire up and tear down an Elasticsearch environment with <a href="http://docs.vagrantup.com/v2/getting-started/">simple commands</a> like <code>vagrant up</code> and <code>vagrant destroy</code>.</p>

<!-- more -->


<p>In order to use Elasticsearch-in-a-box, you first need to have <a href="http://docs.vagrantup.com/v2/installation/">Vagrant</a> and <a href="https://www.virtualbox.org/">VirtualBox</a> installed. These two installations couldn't be any easier. To install <a href="http://thediscoblog.com/blog/2013/10/16/ssh-and-vagrant/">Vagrant</a>, simply go to the downloads page and pick your target distribution. Vagrant provisions machines on top of virtual machine providers like VMWare, <a href="http://thediscoblog.com/blog/categories/aws/">AWS</a>, and VirtualBox. VirtualBox is free and easy to install -- like Vagrant, simply <a href="https://www.virtualbox.org/wiki/Downloads">go to the downloads section</a> and pick your target platform.</p>

<p>Once you have both Vagrant and VirtualBox installed, you are two steps away from Elasticsearch-ing.</p>

<p>First, you need to add and initialize the Elasticsearch-in-a-box <a href="http://docs.vagrantup.com/v2/boxes.html">template</a>. Go ahead and create a directory, like <code>/projects/esinabox</code>, change directories into it and execute this command:</p>

<p><code>bash This command will create a Vagrant definition named esinabox from the downloaded template
vagrant box add esinabox https://s3.amazonaws.com/coffers/esinabox.box
</code></p>

<p>This command will download the Elasticsearch-in-a-box template. Once that completes (it'll take a few moments depending on your connection), execute this command:</p>

<p><code>bash Vagrant init will create a VagrantFile
vagrant init 'esinabox'
</code></p>

<p>This command will create a <code>VagrantFile</code>, which you can use to customize the Elasticsearch-in-a-box instance. By default, you shouldn't need to do much, however, you can map network ports, install additional software via <a href="http://thediscoblog.com/blog/2013/11/18/provisioning-ubuntu-with-java-in-3-steps/">Bash</a>, Chef, and Puppet at your discretion.</p>

<p>Next, fire up Elasticsearch-in-a-box like so:</p>

<p><code>bash Starting up Elasticsearch-in-a-box
vagrant up
</code></p>

<p>Now that Elasticsearch-in-a-box is running locally on your machine, you can open up a new terminal and execute RESTful commands like normal because Elasticsearch is running on same ports: 9200 &amp; 9300. So go ahead and execute some queries, like so:</p>

<p><code>bash Elasticsearch is up an running!
curl -XGET 'http://localhost:9200/_status?pretty=true'
</code></p>

<p>And when you are done, go ahead and tear down the instance like so:</p>

<p><code>bash Destroying a VM instance
vagrant destroy -f
</code></p>

<p>Wasn't that easy? The Elasticsearch-in-a-box Vagrant template was built using <a href="https://github.com/jedi4ever/veewee">Veewee</a>. The base box is 64-bit <a href="http://www.ubuntu.com/index_asus.html">Ubuntu 12.04</a> with Oracle's <a href="http://thediscoblog.com/blog/2013/11/18/provisioning-ubuntu-with-java-in-3-steps/">Java 7</a> and <a href="http://www.elasticsearch.org/download/">Elasticsearch version 0.90.7</a>.</p>

<p>If you're looking for a quick and easy way to automatically provision Elasticsearch, then look no further and give <a href="https://github.com/aglover/coffer">Elasticsearch-in-a-box</a> a try!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Provisioning Ubuntu with Java in 3 steps]]></title>
    <link href="http://thediscoblog.com/blog/2013/11/18/provisioning-ubuntu-with-java-in-3-steps/"/>
    <updated>2013-11-18T17:34:00-05:00</updated>
    <id>http://thediscoblog.com/blog/2013/11/18/provisioning-ubuntu-with-java-in-3-steps</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/mine/ubuntu.png"> <a href="http://thediscoblog.com/blog/2013/10/16/ssh-and-vagrant/">As I've written about before</a>, <a href="http://www.vagrantup.com/">Vagrant</a> is handy tool for creating <a href="http://www.vagrantbox.es/">localized VMs</a>. It's a lot like firing up <a href="http://thediscoblog.com/blog/categories/aws/">EC2</a> images, but, for the most part, things are localized (you can, by the way, use Vagrant to <a href="https://github.com/mitchellh/vagrant-aws">fire up EC2 images</a>). If you've ever used VMWare before, its the same thing, except Vagrant is free. You can create VMs of various operating systems, fire them up, and tear them down all with ease.</p>

<p>Vagrant plays nicely with hip DevOps frameworks like <a href="http://www.opscode.com/chef/">Chef</a> and <a href="http://puppetlabs.com/">Puppet</a> and if your installations require a number of components, then these tools are defiantly the way to go. Sometimes, however, a simple Bash script is good enough as in the case for auto-installing some base component, like <a href="http://thediscoblog.com/blog/categories/java/">Java</a>, <a href="http://thediscoblog.com/blog/categories/node/">Node.js</a> or <a href="http://thediscoblog.com/blog/categories/ruby/">Ruby</a>.</p>

<p>Using Vagrant's configuration file, aptly dubbed <code>Vagrantfile</code>, you can instruct a VM instance to run a series of steps -- these steps can be simple shell scripts, Chef cookbooks, or the Puppet equivalent.</p>

<!-- more -->


<p>Accordingly, the first step to provision an Ubuntu box with Java is to initialize a 64-bit <a href="http://thediscoblog.com/blog/categories/linux/">Ubuntu</a> 12.04 LTS (<a href="https://wiki.ubuntu.com/PrecisePangolin">Precise Pangolin</a>) instance. You can do this via the <code>vagrant init</code> command like so:</p>

<p><code>bash Initializing a Vagrant box
$&gt; vagrant init ubuntu.lts.64 http://files.vagrantup.com/precise64.box
</code></p>

<p>This creates a <code>Vagrantfile</code> in the directory where you ran the command and creates a named VM (i.e. "ubuntu.lts.64") that is based off of Ubuntu 12.04 LTS.</p>

<p>Base Ubuntu installations do not come with Java; if you'd like to install a particular JDK, say Oracle's JDK 7, you can leverage <a href="https://github.com/aglover/ubuntu-equip">ubuntu-equip</a>, which is a series of Bash scripts that install various components like Java, Node.js, MongoDB, Redis, Ruby, etc.</p>

<p>Thus, for step 2, open up the newly created <code>Vagrantfile</code> and you should see two lines like so:</p>

<p>``` ruby A basic VagrantFile contains the box and box_url attributes
config.vm.box = 'ubuntu.lts.64'</p>

<h1>a few comments...</h1>

<p>config.vm.box_url = 'http://files.vagrantup.com/precise64.box'
```</p>

<p>After the <code>vm.box_url</code> declaration, insert the following line:</p>

<p><code>ruby Installing Java
config.vm.provision :shell, inline: 'wget --no-check-certificate https://github.com/aglover/ubuntu-equip/raw/master/equip_java7_64.sh &amp;&amp; bash equip_java7_64.sh'
</code></p>

<p>This command instructs the instance to run an inline Bash command once it is up and running, which in this case auto-installs Oracle's Java 7 JDK (see the <a href="https://github.com/aglover/ubuntu-equip">ubuntu-equip</a> project for more information).</p>

<p>Save your <code>VagrantFile</code> and then, for step 3, run the following command in the same directory:</p>

<p><code>bash Firing up a new VM
$&gt; vagrant up
</code></p>

<p>If this is the first time firing up this particular VM, you should see some text indicating that a particular box is being downloaded. Once the download is complete, the instance will boot up and subsequently invoke the inline provision command that kicks off the installation of Java.</p>

<p>If all goes well, you should see a lot of text scroll by ending with:</p>

<p><code>bash Java is installed!
java version "1.7.0_25"
Java(TM) SE Runtime Environment (build 1.7.0_25-b15)
Java HotSpot(TM) 64-Bit Server VM (build 23.25-b01, mixed mode)
</code></p>

<p>And that's it. To use the VM, <a href="http://thediscoblog.com/blog/2013/10/16/ssh-and-vagrant/">simply SSH to it</a>. Go ahead and type <code>java -version</code> just to convince yourself. Go ahead, I'll wait for you...there, are you happy now?  Wasn't that easy? Provisioning Ubuntu VMs with Vagrant couldn't be any easier with <a href="https://github.com/aglover/ubuntu-equip">ubuntu-equip</a>, dig it?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSH &amp; Vagrant]]></title>
    <link href="http://thediscoblog.com/blog/2013/10/16/ssh-and-vagrant/"/>
    <updated>2013-10-16T15:55:00-04:00</updated>
    <id>http://thediscoblog.com/blog/2013/10/16/ssh-and-vagrant</id>
    <content type="html"><![CDATA[<p><a href="http://www.vagrantup.com/">Vagrant</a> is a handy tool for creating VMs. It's a lot like firing up an <a href="http://thediscoblog.com/blog/categories/aws/">EC2</a> instance, but in Vagrant's case, everything is localized. And best of all, it's free.</p>

<p>I tend to favor <a href="https://github.com/aglover/ubuntu-equip">Ubuntu</a> as my preferred flavor of linux; consequently, all production EC2 instances use a customized Ubuntu AMI. Testing various aspects of this system with various software libraries, however, is initially tested locally using Vagrant VMs. What's more, you can install localized VMs of <a href="http://www.vagrantbox.es/">other operating systems</a> ranging from Debian to OpenSuse to <a href="https://devcenter.heroku.com/articles/stack">Heroku's Cedalon</a>.</p>

<!-- more -->


<p>Firing up a local instance of <a href="http://thediscoblog.com/blog/categories/heroku/">Heroku</a>'s Cedalon (which is a version of Ubuntu 10.04 with Ruby and Node.js installed) is as easy as typing:</p>

<p><code>bash Firing up Heroku's Cedalon locally
vagrant init heroku http://dl.dropbox.com/u/1906634/heroku.box
vagrant up
</code></p>

<p>Then you can SSH to that running VM like so:</p>

<p><code>bash SSHing to a local VM
vagrant ssh
</code></p>

<p>The command <code>vagrant ssh</code> can be problematic, though, especially if you are automating some aspect of SSH -- for example, you are using some library on top of SSH. In that case, you need to use SSH <em>directly</em> rather than through Vagrant.</p>

<p>Luckily, you can SSH normally to local Vagrant instances easily enough. You'll need to tell SSH which key to use (Vagrant creates one for you), which user to connect as (usually vagrant), and what port to connect to (usually 2222).  All of this information can be found via the command <code>vagrant ssh-config</code>.</p>

<p>To use plain Jane SSH when working with Vagrant instances, you'll first need to execute this command:</p>

<p><code>bash Printing out the location of Vagrant's key
vagrant ssh-config | grep IdentityFile  | awk '{print $2}'
</code></p>

<p>This <a href="https://groups.google.com/forum/#!topic/vagrant-up/B5WIfDcIRtE">3 pronged command</a> ultimately tells you where Vagrant has created a key file. The command <a href="http://www.thegeekstuff.com/2010/01/awk-introduction-tutorial-7-awk-print-examples/"><code>awk '{print $2}'</code></a> prints the second column of the line in the <code>ssh-config</code> string that starts with <code>IdentityFile</code> (which points to its location).</p>

<p>Now that you know where the key file is, you can ssh (assuming the default port hasn't changed from 2222 -- double check your <code>ssh-config</code> to make sure) like so:</p>

<p><code>bash Using normal SSH
ssh -i /some/dir/.vagrant.d/insecure_private_key -l vagrant -p 2222 127.0.0.1
</code></p>

<p>If you happen to fire up different VMs -- for example, I have both Heroku Cedalon and normal Ubuntu instances, SSH will probably complain that the remote host identification has changed. This is a valid warning as the RSA fingerprint associated with the local host has indeed changed.</p>

<p>You can suggest that <a href="http://linuxcommando.blogspot.com/2008/10/how-to-disable-ssh-host-key-checking.html">SSH ignore this warning</a> by adding two additional flags. I highly recommend you only do this via the command line and <em>not with some SSH config file</em> as the warning SSH throws is completely legitimate and could be saving you from a man-in-the-middle attack.</p>

<p>Nevertheless, if you are working with localized VMs and need to bypass that warning, use these two flags:</p>

<p><code>bash Two additional flags to SSH
-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no
</code></p>

<p>Consequently, when I SSH to a local Vagrant instance, I type something along the lines of:</p>

<p><code>bash SSHing to Vagrant instances
ssh -i /some/dir/.vagrant.d/insecure_private_key -l vagrant -p 2222 -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no 127.0.0.1
</code></p>

<p>Finally, to shut down a Vagrant instance, just issue the command:</p>

<p><code>
vagrant destroy
</code></p>

<p>Vagrant makes it super easy to fire up localized development environments -- Vagrant instances boot up faster than EC2 instances and they're free. And now you know how to use normal SSH to connect to them. Can you dig it?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AWS EBS in 4 steps]]></title>
    <link href="http://thediscoblog.com/blog/2013/10/12/aws-ebs-in-4-steps/"/>
    <updated>2013-10-12T17:47:00-04:00</updated>
    <id>http://thediscoblog.com/blog/2013/10/12/aws-ebs-in-4-steps</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/mine/4fingers.jpg">When you fire up an AWS AMI, you are given a small partition of disk space that survives reboots. For example, the base <a href="https://github.com/aglover/ubuntu-equip">Ubuntu AMI</a> I tend to favor comes with an 8GB primary partition; however, 8GB is often not enough, especially if you're running a database or something that requires a lot of disk space.</p>

<p>If you poke around on an AMI instance, you'll notice some AMI instances will have additional partitions and in many cases, these partitions will be huge; nevertheless, they're transient and any data on those disks will disappear after a reboot.</p>

<p>Accordingly, if you need to gain some more permanent space on an AMI instance, you'll need to leverage an <a href="http://aws.amazon.com/ebs/">Elastic Block Store (or EBS)</a>, which is basically a permanent hard disk that you can attach to a running AMI instance. The data on an EBS will survive a reboot.</p>

<!-- more -->


<p>Attaching an <a href="http://aws.amazon.com/articles/1667">EBS is super simple</a> and can be done in 4 steps. These steps assume you've got a running AMI; accordingly, if you don't have one up and running, go ahead and do that first. Finally, these instructions are for Linix/Unix systems.</p>

<p>First, you'll need to create an EBS volume in the same zone as the AMI instance. In my case, the instance I'd like to augment with a beefy hard drive resides in us-east-1b. What's more, you'll need to configure how much space you'll want -- you can also select if you'd like to have <a href="http://aws.amazon.com/about-aws/whats-new/2012/07/31/announcing-provisioned-iops-for-amazon-ebs/">provisioned IOPS</a> -- this is a high performance I/O feature of AWS and is intended for databases.</p>

<p><img class="center" src="/images/mine/ebs1.png"></p>

<p>Once the EBS is created, you'll need to <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-attaching-volume.html">attach it</a> to your running AMI -- you can do this by right clicking on the EBS in the AWS Management Console and selecting Attach Volume. You'll need to pick your instance from a drop down. Once you've picked your instance, AWS will suggest a Device -- I suggest you keep it. Click the "Yes, Attach" button.</p>

<p><img class="center" src="/images/mine/ebs2.png"></p>

<p>SSH onto your running instance and take a peek at the <code>/proc/partitions</code> file -- you should see at least 2 partitions with your newly attached one on the bottom.  The blocks are listed in kilobytes and pay special attention to the name -- you'll need it for the next few steps.</p>

<p>``` bash The contents of /proc/partitions
ubuntu@ip-10-194-97-73:~$ cat /proc/partitions
major minor  #blocks  name</p>

<p> 202        1    8388608 xvda1
 202       80    8388608 xvdf
```</p>

<p>As you can see above, there is an 8GB EBS volume named <code>xvdf</code> in the <code>partitions</code> file.</p>

<p>Next, you'll want to format the volume -- I'm going to format the EBS volume as ext4. The command to do this is:</p>

<p><code>bash Foratting an EBS volume
sudo mke2fs -F -t ext4 /dev/xvdf
</code></p>

<p>Now that the volume is formatted, I can mount it -- I'm going to mount it to a directory called <code>/ebs</code>; accordingly, I need to create the <code>/ebs</code> directory and then mount the <code>xvdf</code> device like so:</p>

<p><code>bash Creating and mounting the device to the ebs directory
sudo mkdir /ebs
sudo mount /dev/xvdf /ebs
</code></p>

<p>At this point, you are 98% done; however, the volume will not be reattached if this instance is rebooted.</p>

<p>To make this EBS volume automatically reattach after a reboot, you'll need to add it to the <code>fstab</code> file (it's in the <code>/etc</code> directory). When you edit that file, the file system will be
what ever you mounted (i.e <code>/dev/xvdf</code>), the mount point will be the directory you mounted it to -- in my case, it's <code>/ebs</code>. The type will be ext4 (if you formatted it that way) and for options, put default. The last two values can be 0 as well.</p>

<p>If you need to remove your EBS volume, on the attached instance, run</p>

<p><code>bash Unmounting a device
sudo umount -d /dev/xvdf
</code></p>

<p>And then go into the AWS Management Console, find your EBS volume, right click on it and select detach volume.</p>

<p>That's it -- you're done! You've got a permanent store. In 4 steps, you've created an EBS volume, attached it to a running AMI, formatted and mounted it. And you've made it attach automatically after a reboot.  Can you dig it?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cURLing for Wget]]></title>
    <link href="http://thediscoblog.com/blog/2013/04/18/curling-for-wget/"/>
    <updated>2013-04-18T09:33:00-04:00</updated>
    <id>http://thediscoblog.com/blog/2013/04/18/curling-for-wget</id>
    <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/Wget">Wget</a> is an extremely handy utility I use all the time when I find myself on a Linux box. It's quite helpful, for example, for downloading files. Need to <a href="https://github.com/aglover/ubuntu-equip/blob/master/equip_ruby.sh">install Ruby</a>? No problem, just download the binary like so:</p>

<p><code>bash wget example of downloading Ruby binary
wget http://ftp.ruby-lang.org/pub/ruby/1.9/ruby-1.9.2-p180.tar.gz
</code></p>

<p>and you're one step closer. There's no flags to remember either.</p>

<!--more-->


<p>Wget, however, isn't natively available on OSX. From time to time, I'm stung to see the nefarious 'command not found' message after expectantly waiting to see some file I need downloaded.</p>

<p>Luckily, you can force <a href="http://curl.haxx.se/docs/manpage.html">cURL</a> to act like Wget with a few flags. Simply use the <code>-OL</code> flags like so:</p>

<p><code>bash cURL acting like Wget
curl -OL http://ftp.ruby-lang.org/pub/ruby/1.9/ruby-1.9.2-p180.tar.gz
</code></p>

<p>and you'll be on your way to downloading some file.</p>

<p>Of course, it's possible to get <code>wget</code> on your Mac via <a href="http://osxdaily.com/2012/05/22/install-wget-mac-os-x/">MacPorts or Homebrew</a>; nevertheless, knowing you can achieve the same goals with cURL is always handy.</p>
]]></content>
  </entry>
  
</feed>
