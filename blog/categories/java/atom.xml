<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | The Disco Blog]]></title>
  <link href="http://thediscoblog.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://thediscoblog.com/"/>
  <updated>2014-01-24T21:11:14-08:00</updated>
  <id>http://thediscoblog.com/</id>
  <author>
    <name><![CDATA[Andrew Glover]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Elasticsearch in a box]]></title>
    <link href="http://thediscoblog.com/blog/2013/11/25/elasticsearch-in-a-box/"/>
    <updated>2013-11-25T13:42:00-08:00</updated>
    <id>http://thediscoblog.com/blog/2013/11/25/elasticsearch-in-a-box</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/mine/esbox.jpg">Are you looking to get going with <a href="http://thediscoblog.com/blog/categories/elasticsearch/">Elasticsearch</a> as quickly as possible without having to worry about <a href="http://thediscoblog.com/blog/2013/05/17/elasticsearch-on-ec2-in-less-than-60-seconds/">installing Java or Elasticsearch</a> itself? Are you looking for a repeatable and automated mechanism for bringing up Elasticsearch instances for developmental and or testing purposes? While there's certainly a number of <a href="http://www.elasticsearch.org/">Elasticsearch</a>-as-a-platform service providers out there, there's one other option: use <a href="https://github.com/aglover/coffer">Elasticsearch-in-a-box</a>.</p>

<p>Elasticsearch-in-a-box is a freely available <a href="http://www.vagrantbox.es/">Vagrant base box</a>. What that means is that you can quickly fire up and tear down an Elasticsearch environment with <a href="http://docs.vagrantup.com/v2/getting-started/">simple commands</a> like <code>vagrant up</code> and <code>vagrant destroy</code>.</p>

<!-- more -->


<p>In order to use Elasticsearch-in-a-box, you first need to have <a href="http://docs.vagrantup.com/v2/installation/">Vagrant</a> and <a href="https://www.virtualbox.org/">VirtualBox</a> installed. These two installations couldn't be any easier. To install <a href="http://thediscoblog.com/blog/2013/10/16/ssh-and-vagrant/">Vagrant</a>, simply go to the downloads page and pick your target distribution. Vagrant provisions machines on top of virtual machine providers like VMWare, <a href="http://thediscoblog.com/blog/categories/aws/">AWS</a>, and VirtualBox. VirtualBox is free and easy to install -- like Vagrant, simply <a href="https://www.virtualbox.org/wiki/Downloads">go to the downloads section</a> and pick your target platform.</p>

<p>Once you have both Vagrant and VirtualBox installed, you are two steps away from Elasticsearch-ing.</p>

<p>First, you need to add and initialize the Elasticsearch-in-a-box <a href="http://docs.vagrantup.com/v2/boxes.html">template</a>. Go ahead and create a directory, like <code>/projects/esinabox</code>, change directories into it and execute this command:</p>

<p><code>bash This command will create a Vagrant definition named esinabox from the downloaded template
vagrant box add esinabox https://s3.amazonaws.com/coffers/esinabox.box
</code></p>

<p>This command will download the Elasticsearch-in-a-box template. Once that completes (it'll take a few moments depending on your connection), execute this command:</p>

<p><code>bash Vagrant init will create a VagrantFile
vagrant init 'esinabox'
</code></p>

<p>This command will create a <code>VagrantFile</code>, which you can use to customize the Elasticsearch-in-a-box instance. By default, you shouldn't need to do much, however, you can map network ports, install additional software via <a href="http://thediscoblog.com/blog/2013/11/18/provisioning-ubuntu-with-java-in-3-steps/">Bash</a>, Chef, and Puppet at your discretion.</p>

<p>Next, fire up Elasticsearch-in-a-box like so:</p>

<p><code>bash Starting up Elasticsearch-in-a-box
vagrant up
</code></p>

<p>Now that Elasticsearch-in-a-box is running locally on your machine, you can open up a new terminal and execute RESTful commands like normal because Elasticsearch is running on same ports: 9200 &amp; 9300. So go ahead and execute some queries, like so:</p>

<p><code>bash Elasticsearch is up an running!
curl -XGET 'http://localhost:9200/_status?pretty=true'
</code></p>

<p>And when you are done, go ahead and tear down the instance like so:</p>

<p><code>bash Destroying a VM instance
vagrant destroy -f
</code></p>

<p>Wasn't that easy? The Elasticsearch-in-a-box Vagrant template was built using <a href="https://github.com/jedi4ever/veewee">Veewee</a>. The base box is 64-bit <a href="http://www.ubuntu.com/index_asus.html">Ubuntu 12.04</a> with Oracle's <a href="http://thediscoblog.com/blog/2013/11/18/provisioning-ubuntu-with-java-in-3-steps/">Java 7</a> and <a href="http://www.elasticsearch.org/download/">Elasticsearch version 0.90.7</a>.</p>

<p>If you're looking for a quick and easy way to automatically provision Elasticsearch, then look no further and give <a href="https://github.com/aglover/coffer">Elasticsearch-in-a-box</a> a try!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Book review: Instant Mockito]]></title>
    <link href="http://thediscoblog.com/blog/2013/11/22/book-review-instant-mockito/"/>
    <updated>2013-11-22T13:33:00-08:00</updated>
    <id>http://thediscoblog.com/blog/2013/11/22/book-review-instant-mockito</id>
    <content type="html"><![CDATA[<p>Recently, the good folks over at <a href="http://www.packtpub.com/">Packt Publishing</a> gave me a copy of their newly published <a href="http://www.amazon.com/gp/product/B00ESX15M2/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=B00ESX15M2&amp;linkCode=as2&amp;tag=thdibl-20"><em>Instant Mockito</em></a>, by <a href="http://toomuchcoding.blogspot.com/">Marcin Grzejszczak</a>. Packt's <a href="http://www.packtpub.com/books/instant">Instant series</a> are really enjoyable. The premise of these books is that they're short and sweet. They're slightly more than a tutorial; they get you up and running quickly while throwing in a few more facets that go beyond the typical tutorial.</p>

<!-- more -->


<p></p>

<iframe style="float: right; margin-left: 1.5em; height:260px; width:150px;" src="http://rcm-na.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=thdibl-20&o=1&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=B00ESX15M2" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>


<p><a href="http://www.amazon.com/gp/product/B00ESX15M2/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=B00ESX15M2&amp;linkCode=as2&amp;tag=thdibl-20"><em>Instant Mockito</em></a> is a quick read at 92 pages; what's more, Marcin does a great job of keeping a consistent example domain alive throughout the entire book. The big picture is how to use <a href="http://thediscoblog.com/blog/2013/08/01/imbibing-the-fluency-of-mockito/">Mockito</a> with <a href="http://thediscoblog.com/blog/2013/08/04/sometimes-tdd-requires-a-hammer/">JUnit</a>, testing a fictitious restaurant ordering system.</p>

<p>The format of Packt's Instant books are all similar — the first part is a quick "up and running" that essentially encapsulates the basic tutorial you can find on a project's home page. The meat of an Instant book comes next, where the author dives into a number of features they feel are important to grasp a particular subject.</p>

<p>In the case of <a href="http://www.packtpub.com/how-to-create-stubs-mocks-spies-using-mockito/book">Marcin's book</a>, he elaborates on 8 key Mockito subjects:</p>

<ul>
<li>Performing argument matching</li>
<li>Stubbing multiple calls</li>
<li>Working with void methods and thrown exceptions</li>
<li>Stubbing with a custom answer</li>
<li>Verifying behavior (including argument capturing, verifying call order, and working with asynchronous code)</li>
<li>Doing partial mocking (spying)</li>
<li>Reducing boilerplate code with annotations</li>
<li>Taking advantage of advanced mocks configuration</li>
</ul>


<p>Again, each subject expands upon a waiter-taking-an-order domain. As this is a book focusing on Mockito, the mocking aspects are straightforward — this isn't a book on how to test poorly written code, for example, so the code under test in this case uses dependency injection. This makes it easy to grasp Mockito subjects without having to delve into the intricacies of terrible code (ironically, I often times find myself employing Mockito when dealing with poorly written code).</p>

<p>Speaking of poorly written code: the only thing I did not particularly enjoy about the book was the formatting of the code. Code formatting has always been problematic in books, however, many publishers have figured out how to properly convey code (in particular, <a href="http://www.oreilly.com/">O'Reilly</a> books do a good job).</p>

<p>In the case of <a href="http://www.amazon.com/gp/product/B00ESX15M2/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=B00ESX15M2&amp;linkCode=as2&amp;tag=thdibl-20"><em>Instant Mockito</em></a>, the code examples (at least reading the epub version on my iPad) have such narrow margins that each logical line of code is often broken into 3 or more lines (and dashes are used to signify a line break). While it certainly doesn't render the code unreadable, it makes instant code comprehension challenging. I found myself having to read through each code example multiple times just to get the basic idea.</p>

<p>Code formatting aside, <a href="http://www.packtpub.com/how-to-create-stubs-mocks-spies-using-mockito/book">Marcin's book was an easy read</a> and the 8 features he feels every Mockito user should know are well explained.  As a user of Mockito, I couldn't agree more with the relevance of these features. If you enjoy quick reads, want to learn the basics of mocking in JUnit with Mockito, and you can put up with inadequate code formatting, then go ahead and give <a href="http://www.amazon.com/gp/product/B00ESX15M2/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=B00ESX15M2&amp;linkCode=as2&amp;tag=thdibl-20"><em>Instant Mockito</em></a> a read!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Provisioning Ubuntu with Java in 3 steps]]></title>
    <link href="http://thediscoblog.com/blog/2013/11/18/provisioning-ubuntu-with-java-in-3-steps/"/>
    <updated>2013-11-18T17:34:00-08:00</updated>
    <id>http://thediscoblog.com/blog/2013/11/18/provisioning-ubuntu-with-java-in-3-steps</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/mine/ubuntu.png"> <a href="http://thediscoblog.com/blog/2013/10/16/ssh-and-vagrant/">As I've written about before</a>, <a href="http://www.vagrantup.com/">Vagrant</a> is handy tool for creating <a href="http://www.vagrantbox.es/">localized VMs</a>. It's a lot like firing up <a href="http://thediscoblog.com/blog/categories/aws/">EC2</a> images, but, for the most part, things are localized (you can, by the way, use Vagrant to <a href="https://github.com/mitchellh/vagrant-aws">fire up EC2 images</a>). If you've ever used VMWare before, its the same thing, except Vagrant is free. You can create VMs of various operating systems, fire them up, and tear them down all with ease.</p>

<p>Vagrant plays nicely with hip DevOps frameworks like <a href="http://www.opscode.com/chef/">Chef</a> and <a href="http://puppetlabs.com/">Puppet</a> and if your installations require a number of components, then these tools are defiantly the way to go. Sometimes, however, a simple Bash script is good enough as in the case for auto-installing some base component, like <a href="http://thediscoblog.com/blog/categories/java/">Java</a>, <a href="http://thediscoblog.com/blog/categories/node/">Node.js</a> or <a href="http://thediscoblog.com/blog/categories/ruby/">Ruby</a>.</p>

<p>Using Vagrant's configuration file, aptly dubbed <code>Vagrantfile</code>, you can instruct a VM instance to run a series of steps -- these steps can be simple shell scripts, Chef cookbooks, or the Puppet equivalent.</p>

<!-- more -->


<p>Accordingly, the first step to provision an Ubuntu box with Java is to initialize a 64-bit <a href="http://thediscoblog.com/blog/categories/linux/">Ubuntu</a> 12.04 LTS (<a href="https://wiki.ubuntu.com/PrecisePangolin">Precise Pangolin</a>) instance. You can do this via the <code>vagrant init</code> command like so:</p>

<p><code>bash Initializing a Vagrant box
$&gt; vagrant init ubuntu.lts.64 http://files.vagrantup.com/precise64.box
</code></p>

<p>This creates a <code>Vagrantfile</code> in the directory where you ran the command and creates a named VM (i.e. "ubuntu.lts.64") that is based off of Ubuntu 12.04 LTS.</p>

<p>Base Ubuntu installations do not come with Java; if you'd like to install a particular JDK, say Oracle's JDK 7, you can leverage <a href="https://github.com/aglover/ubuntu-equip">ubuntu-equip</a>, which is a series of Bash scripts that install various components like Java, Node.js, MongoDB, Redis, Ruby, etc.</p>

<p>Thus, for step 2, open up the newly created <code>Vagrantfile</code> and you should see two lines like so:</p>

<p>``` ruby A basic VagrantFile contains the box and box_url attributes
config.vm.box = 'ubuntu.lts.64'</p>

<h1>a few comments...</h1>

<p>config.vm.box_url = 'http://files.vagrantup.com/precise64.box'
```</p>

<p>After the <code>vm.box_url</code> declaration, insert the following line:</p>

<p><code>ruby Installing Java
config.vm.provision :shell, inline: 'wget --no-check-certificate https://github.com/aglover/ubuntu-equip/raw/master/equip_java7_64.sh &amp;&amp; bash equip_java7_64.sh'
</code></p>

<p>This command instructs the instance to run an inline Bash command once it is up and running, which in this case auto-installs Oracle's Java 7 JDK (see the <a href="https://github.com/aglover/ubuntu-equip">ubuntu-equip</a> project for more information).</p>

<p>Save your <code>VagrantFile</code> and then, for step 3, run the following command in the same directory:</p>

<p><code>bash Firing up a new VM
$&gt; vagrant up
</code></p>

<p>If this is the first time firing up this particular VM, you should see some text indicating that a particular box is being downloaded. Once the download is complete, the instance will boot up and subsequently invoke the inline provision command that kicks off the installation of Java.</p>

<p>If all goes well, you should see a lot of text scroll by ending with:</p>

<p><code>bash Java is installed!
java version "1.7.0_25"
Java(TM) SE Runtime Environment (build 1.7.0_25-b15)
Java HotSpot(TM) 64-Bit Server VM (build 23.25-b01, mixed mode)
</code></p>

<p>And that's it. To use the VM, <a href="http://thediscoblog.com/blog/2013/10/16/ssh-and-vagrant/">simply SSH to it</a>. Go ahead and type <code>java -version</code> just to convince yourself. Go ahead, I'll wait for you...there, are you happy now?  Wasn't that easy? Provisioning Ubuntu VMs with Vagrant couldn't be any easier with <a href="https://github.com/aglover/ubuntu-equip">ubuntu-equip</a>, dig it?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[All other metrics are useless]]></title>
    <link href="http://thediscoblog.com/blog/2013/10/09/all-other-metrics-are-useless/"/>
    <updated>2013-10-09T18:04:00-07:00</updated>
    <id>http://thediscoblog.com/blog/2013/10/09/all-other-metrics-are-useless</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/mine/time1.jpg">When it comes to queues, whether they're implemented as <a href="http://en.wikipedia.org/wiki/Java_Message_Service">JMS</a>, database tables (i.e. what Ruby's <a href="http://thediscoblog.com/blog/2013/06/10/backgrounding-tasks-in-heroku-with-delayed-job/">Delayed::Job</a> uses for a queue), or even <a href="http://aws.amazon.com/sqs/">Amazon's SQS</a>, the most common metric used to evaluate the state of a queue is its length. In essence, one derives an efficiency metric based upon how many messages are residing in a queue at any given time. If there are just a few messages, the queue is operating efficiently. If there are numerous messages, things are inefficient and alarms must be sounded.</p>

<!-- more -->


<p>But what if you're in a consistently busy environment with extreme bursts where queues have the tendency to rapidly fill up? If you have sufficient workers <em>already running</em> to handle that burst, do you need to fire up more?</p>

<p>You can fire up more workers, but doing so might cost you. That is, you might have to provision new worker instances, such as <a href="https://devcenter.heroku.com/articles/dynos">Heroku worker dynos</a> or AWS AMIs, which will end up costing you tangible money. And sometimes those worker instances take a few moments to fire up and when they're operational, the burst of activity is over and the queue is back to normal -- the initially available workers handled the load adequately.</p>

<p>It turns out that the queue's length was a lagging indicator. You spun up unneeded resources. False alarm!</p>

<p>If you already have sufficient capacity to handle the influx of messages on a queue, then monitoring a queue's length isn't too helpful. In fact, it's a misleading metric and can cause you to take unneeded actions.</p>

<p>Consequently, a queue's length <em>is not indicative of a system's efficiency</em> when there's already sufficient workers present. Rather, the metric that means something in a high capacity environment is <em>how long a message resides in a queue</em>. That is an actionable metric: if messages are stuck in a queue waiting to be processed then you need more processors!</p>

<h2>Moo over queue length and let queue wait time in</h2>

<p>By default, <a href="http://www.ibm.com/developerworks/library/j-javadev2-17/">Amazon's SQS</a> doesn't provide the ability to query how long a message has been residing in a queue. Therefore, <a href="https://github.com/aglover/moo">I wrote Moo</a>.</p>

<p>Moo provides an interface for clients to obtain and take action on the message time in queue metric. This is done by augmenting an SQS message with a time stamp. That time stamp is then checked when a message is popped off of an SQS queue. If a threshold difference is exceed, then a callback is invoked.</p>

<p>Users of Moo will find its usage similar to <a href="https://github.com/aglover/ahoy">Ahoy!</a>, which is an asynchronous callback oriented facade on top of <a href="http://aws.amazon.com/sdkforjava/">AWS's Java SDK</a>. In fact, Moo uses Ahoy! underneath, with the added feature of attaching a "maximum time in queue" asynchronous callback.</p>

<p>Moo supports multiple time in queue thresholds and setting a maximum time in queue threshold is done like so:</p>

<p>``` java Adding a maximum threshold for time in queue
//adds a 1 second max threshold
sqs.addQueueWaitTimeCallback(1000, new QueueWaitTimeCallback() {
  public void onThresholdExceeded(long waitTime) {</p>

<pre><code>//waitTime is the actual time in queue
//do something... like fire off a web hook, etc
</code></pre>

<p>  }
});
```</p>

<p>Note the <code>addQueueWaitTimeCallback</code> method takes a millisecond maximum time in queue value and an accompanying <code>QueueWaitTimeCallback</code> callback implementation. The <code>onThresholdExceeded</code> method will be invoked asynchronously during a message receive if the maximum threshold value is exceeded; what's more, the <code>onThresholdExceeded</code> will receive as a parameter the actual queue wait time.</p>

<h4>Show me the Moo</h4>

<p>To fire up an instance of Moo, you have a number of options, including configuring an instance of AWS's <code>AmazonSQS</code> or just passing along a key, secret, and queue name like so:</p>

<p><code>
SQS sqs = new SQS(System.getProperty("key"), System.getProperty("secret"), System.getProperty("queue"));
</code></p>

<p>Next, you can attach zero to many <code>QueueWaitTimeCallback</code> instances like so:</p>

<p>```
sqs.addQueueWaitTimeCallback(600000, new QueueWaitTimeCallback() {
  public void onThresholdExceeded(long actualWaitTime) {</p>

<pre><code>//do something -- fire off SNS message?
</code></pre>

<p>  }
});
```</p>

<p>In this case, I've added a callback to be invoked if messages are in a queue longer than 10 minutes. Note, these <code>QueueWaitTimeCallback</code> callbacks are fired by the <em>queue reader</em> instance; accordingly, a <code>QueueWaitTimeCallback</code> can certainly fire up more instances of itself, for example.</p>

<p>Here's a sample JSON document that you might want to throw onto an SQS queue:</p>

<p>```
{ "employees":[</p>

<pre><code>  { "firstName":"John", "lastName":"Doe" },
  { "firstName":"Anna", "lastName":"Smith" },
  { "firstName":"Peter", "lastName":"Jones" }
</code></pre>

<p>]}
```</p>

<p>Sending and receiving this message are exactly like you'd do if you were using Ahoy!. For example, to send a message, just pass along a <code>String</code> to the <code>send</code> method:</p>

<p>```
sqs.send(json, new SendCallback() {
  public void onSend(String messageId) {</p>

<pre><code>//messageId is from SQS
</code></pre>

<p>  }
});
```</p>

<p>Note, the <code>send</code> method takes an optional <code>SendCallback</code>.</p>

<p>Receiving a message is via the <code>receive</code> method, which takes a mandatory <code>ReceiveCallback</code> -- this callback will be invoked asynchronously <em>for each</em> message received off of a queue. Each instance will receive the message placed upon the queue and the message's SQS id.</p>

<p>```
sqs.receive(new ReceiveCallback() {
  public void onReceive(String messageId, String message) {</p>

<pre><code>//do something w/the message -- in this case it's JSON
</code></pre>

<p>  }
});
```</p>

<p>Note, if upon the receive of a message, Moo notices that a message has been waiting in a queue for more than the max queue wait time threshold configured for an associated <code>QueueWaitTimeCallback</code>, Moo will invoke it. Note, Moo can invoke more than one instance; thus, you can set up a chain to take various actions as times increase.</p>

<p>Remember, a queue's length is usually a lagging indicator.  The metric that actually means something is how long a message resides in a queue. That's an actionable metric and <a href="https://github.com/aglover/moo">Moo</a> gives you the ability to do something about it! Can you dig it?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ahoy there callbacks!]]></title>
    <link href="http://thediscoblog.com/blog/2013/09/29/ahoy-there-callbacks/"/>
    <updated>2013-09-29T16:30:00-07:00</updated>
    <id>http://thediscoblog.com/blog/2013/09/29/ahoy-there-callbacks</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/mine/callback.jpg">Because it's my bag, I like <a href="http://thediscoblog.com/blog/categories/javascript/">JavaScript</a>. In fact, I've grown to love JavaScritp's asynchronous <a href="http://en.wikipedia.org/wiki/Callback_(computer_programming">callback oriented style of programming</a>. Consequently, when I find myself in a non-JavaScript environment, say, like <a href="http://thediscoblog.com/blog/categories/java/">Java</a>, I tend to miss using callbacks.</p>

<p>The good news is that you can <em>emulate</em> asynchronous callbacks in Java. In fact, I did just that recently with a library I've dubbed <a href="https://github.com/aglover/ahoy">Ahoy!</a>, which is an asynchronous <a href="http://www.ibm.com/developerworks/library/j-javadev2-17/">SQS adapter</a> for AWS's Java <a href="http://aws.amazon.com/sqs/">SQS</a> library.</p>

<!-- more -->


<p>For the uninitiated, <a href="http://www.ibm.com/developerworks/library/j-javadev2-17/">SQS is a cloud based messaging platform</a> -- with SQS you can create queues and put messages onto those queues, which can then be read -- later or immediately by some other process or the same exact process. All of this leverages Amazon’s massively redundant architecture to offer extremely high availability in the face of concurrent access.</p>

<p>Asynchronous callbacks in Java can be achieved with two features: anonymous classes (containing one method) and Java's <code>java.util.concurrent</code> package.</p>

<p>Because Java doesn't allow you to pass functions (or methods) <em>easily</em> as a parameter, to simulate a callback, you can create an interface that contains one method, which basically mimics a function. In the case of Ahoy, there are two interfaces: <code>MessageSendCallback</code> and <code>MessageReceivedCallback</code> -- both have one method: <code>onSend</code> and <code>onReceive</code> respectively. Accordingly, Ahoy!''s primary class, dubbed <code>SQSAdapter</code> exposes two simple methods: <code>send</code> and <code>receive</code> and both take their related callback interface.</p>

<p>The most straightforward callback to understand is the <code>receive</code> method. As you can imagine, <code>receive</code> is intended to handle behavior when a message is received off of a particular queue. Thus, the <code>receive</code> method is defined as follows:</p>

<p><code>java SQSAdapter's receive method
public void receive(final MessageReceivedCallback callback) {}
</code></p>

<p>The <code>MessageReceivedCallback</code> interface looks like this:</p>

<p>``` java The MessageReceivedCallback interface
public interface MessageReceivedCallback {</p>

<pre><code>public void onReceive(String messageId, String message);
</code></pre>

<p>}
```</p>

<p>Note, the <code>onReceive</code> method takes a message id (which is particular to SQS) and the message itself -- which in the case of SQS is always a <code>String</code> (that <code>String</code> can hold anything you want, keep in mind: JSON, XML, byte sequence, etc).</p>

<p>Thus, clients of Ahoy! provide the intended behavior for a message when it is received. This behavior could be to write something to a database, generate another message and send it on another queue, you name it.</p>

<p>Now the interesting part is the implementation of Ahoy!'s <code>receive</code> method. To achieve asynchronocity, I employed Java's <code>java.util.concurrent</code> package, which sadly, seems to be under appreciated.</p>

<p>``` java The receive method's implementation with callback being invoked
private void receive(final AmazonSQS sqs, final String queueURL, final MessageReceivedCallback callback) {
  pool.execute(new Runnable() {</p>

<pre><code>public void run() {
  final List&lt;Message&gt; messages = sqs.receiveMessage(
          new ReceiveMessageRequest(queueURL).withMaxNumberOfMessages(10).withWaitTimeSeconds(20)).getMessages();
  if (messages.size() &gt; 0) {
      for (final Message message : messages) {
        callback.onReceive(message.getMessageId(), message.getBody());
        sqs.deleteMessage(new DeleteMessageRequest(queueURL, message.getReceiptHandle()));
      }
  }
}
</code></pre>

<p>  });
}
```</p>

<p>With a fixed Thread pool, a thread is created, which waits for messages to arrive on a particular queue; when one shows up, the passed in <code>MessageReceivedCalledback</code> is invoked for each message.</p>

<p>For an example of how this works for clients of Ahoy!, here's a test case that verifies the execution of the callback:</p>

<p>``` java The receive method implemented
final boolean[] wasReceived = {false};
ahoy.receive(new MessageReceivedCallback() {
  public void onReceive(String messageId, String message) {</p>

<pre><code>wasReceived[0] = true;
assertNotNull("message id was null", messageId);
assertEquals("message wasn't " + origMessage, origMessage, message);
</code></pre>

<p>  }
});
```</p>

<p>Likewise, sending a message is similar -- a new <code>Runnable</code> instance is created, which sends a particular message and invokes the passed in <code>MessageSentCallback</code>'s <code>onSend</code> method, passing in the newly sent messages's id.</p>

<p>``` java The send method is also asynchronous
private void send(final AmazonSQS sqs, final String queueURL, final String message, final MessageSentCallback callback) {
  pool.execute(new Runnable() {</p>

<pre><code>  public void run() {
  SendMessageResult res = sqs.sendMessage(new SendMessageRequest(queueURL, message));
  if (callback != null) {
    callback.onSend(res.getMessageId());
  }
  }
</code></pre>

<p>  });
}
```</p>

<p>Incidentally, the AWS Java SDK <em>does provide an asynchronous client</em>; however, this client's implementation leverages Java's <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html">Futures</a>. While <a href="http://nurkiewicz.blogspot.com/2013/02/javautilconcurrentfuture-basics.html">Futures are a neat concept</a>, Ahoy!'s implementation is more convenient (<em>at least for me and in the patterns of how I employ SQS</em>) than Futures as there isn't any polling involved once a message is sent or received.</p>

<p>While callbacks aren't <a href="http://en.wikipedia.org/wiki/Function_object#In_Java">necessarily supported</a> natively in Java, you can emulate them quite nicely and achieve the same level of code conciseness as what's common in JavaScript. And if you need a handy way to interface with AWS SQS, <a href="https://github.com/aglover/ahoy">then give Ahoy! a try</a>! Can you dig it, man?</p>
]]></content>
  </entry>
  
</feed>
